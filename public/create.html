<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Video Dubbing & Green Screen Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="/libs/selfie_segmentation.js" defer></script>
    <script src="/libs/RecordRTC.js" defer></script>
    <style>
        body { font-family: 'Inter', sans-serif; background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); min-height: 100vh; }
        .loader { border: 4px solid #374151; border-top: 4px solid #3b82f6; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; display: inline-block; margin-right: 0.5rem; vertical-align: middle; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .app-container { max-width: 900px; }
        #canvas-container { 
            position: relative; width: 100%; 
            background: #000; aspect-ratio: 16 / 9; border-radius: 0.75rem; overflow: hidden; 
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3); 
        }
        #main-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; border-radius: 0.75rem; }
        .custom-modal { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background-color: rgba(0, 0, 0, 0.8); backdrop-filter: blur(4px); 
            display: flex; align-items: center; justify-content: center; z-index: 50; padding: 1rem; 
        }
        .modal-content { 
            background: linear-gradient(135deg, #1f2937 0%, #111827 100%); padding: 2rem; border-radius: 0.75rem; 
            text-align: center; max-width: 90%; width: 500px; 
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); border: 1px solid #374151; 
        }
        
        .preview-container {
            position: fixed; bottom: 1rem; right: 1rem; width: 220px; height: 124px;
            border-radius: 0.75rem; overflow: hidden; box-shadow: 0 10px 25px rgba(0,0,0,0.6); z-index: 40;
            background: #111827; transition: all 0.3s ease;
        }
        #raw-camera-preview-container { border: 3px solid #3b82f6; } 
        #greenscreen-preview-container { border: 3px solid #10b981; }
        .preview-video, .preview-canvas { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); border-radius: 0.5rem; }
        
        .glass-effect { background: rgba(31, 41, 55, 0.8); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1); }
        .gradient-text { background: linear-gradient(135deg, #3b82f6 0%, #10b981 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        
        .btn-primary { background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%); box-shadow: 0 4px 14px rgba(59, 130, 246, 0.3); }
        .btn-primary:hover { box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4); transform: translateY(-1px); }
        .btn-secondary { background: linear-gradient(135deg, #10b981 0%, #059669 100%); box-shadow: 0 4px 14px rgba(16, 185, 129, 0.3); }
        .btn-secondary:hover { box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4); transform: translateY(-1px); }

        .hidden { display: none !important; }

        /* Full Screen Preview Styles */
        #fullscreen-preview {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #fullscreen-canvas {
            width: 100%; height: 100%; object-fit: contain;
        }
        #fullscreen-controls {
            position: absolute; bottom: 0; left: 0; width: 100%;
            padding: 1rem 2rem;
            display: flex; align-items: center; justify-content: center;
            background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
        }
        #record-btn {
            width: 70px; height: 70px;
            border-radius: 50%;
            background-color: #ef4444;
            border: 4px solid white;
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.7);
            transition: all 0.2s ease;
            display: flex; align-items: center; justify-content: center;
        }
        #record-btn:hover { transform: scale(1.1); }
        #record-btn.recording {
            border-radius: 15%;
            background-color: #dc2626;
            animation: pulse 1.5s infinite;
        }
        #record-btn.recording .record-icon { display: none; }
        #record-btn .stop-icon { display: none; }
        #record-btn.recording .stop-icon { display: block; }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        #countdown-timer {
            position: absolute; top: 1.5rem; right: 1.5rem;
            background-color: rgba(0,0,0,0.5);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 999px;
            font-size: 1.25rem;
            font-weight: 600;
            font-family: monospace;
        }
        #exit-preview-btn, #toggle-audio-btn {
            position: absolute; top: 1.5rem;
            background: rgba(41, 51, 65, 0.7);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            width: 44px; height: 44px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #exit-preview-btn { left: 1.5rem; }
        #toggle-audio-btn { left: 5rem; }
        #toggle-audio-btn:hover { background-color: rgba(55, 65, 81, 0.8); }
        #toggle-audio-btn .icon-unmuted { display: block; }
        #toggle-audio-btn .icon-muted { display: none; }
        #toggle-audio-btn.muted .icon-unmuted { display: none; }
        #toggle-audio-btn.muted .icon-muted { display: block; }
    </style>
    <!-- Now using self-hosted versions above -->
</head>
<body class="text-white antialiased">
    <!-- UI Elements -->
    <div id="raw-camera-preview-container" class="preview-container hidden">
        <video id="raw-camera-preview" class="preview-video" playsinline muted autoplay></video>
    </div>
    <div id="greenscreen-preview-container" class="preview-container hidden">
        <canvas id="greenscreen-preview-canvas" class="preview-canvas"></canvas>
    </div>
    <div class="container mx-auto p-4 md:p-8 app-container">
        <header class="text-center mb-12">
            <h1 class="text-5xl font-bold tracking-tight gradient-text sm:text-6xl mb-4">Video Dub Studio</h1>
            <p id="subtitle" class="text-xl text-gray-300">Professional video dubbing and green screen effects</p>
        </header>
        <main>
            <div id="start-section" class="text-center">
                <div class="glass-effect p-8 rounded-2xl mb-8"><div class="mb-6"><div class="w-20 h-20 mx-auto mb-4 rounded-full bg-gradient-to-r from-blue-500 to-green-500 flex items-center justify-center"><svg class="w-10 h-10 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></div><h2 class="text-2xl font-semibold mb-2">Ready to Create?</h2><p class="text-gray-400">We'll need access to your camera and microphone to get started</p></div><button id="start-btn" type="button" class="btn-primary text-white font-bold py-4 px-8 rounded-xl text-xl transition-all duration-300">Start Studio</button></div>
            </div>
            <div id="app-content" class="hidden space-y-8">
                <div id="upload-section" class="glass-effect p-8 rounded-2xl">
                    <h2 class="text-3xl font-bold mb-6 text-center gradient-text">1. Upload Your Video</h2>
                    <div class="border-2 border-dashed border-gray-600 rounded-xl p-8 text-center hover:border-blue-500 transition-colors duration-300"><svg class="w-12 h-12 mx-auto mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg><input type="file" id="video-upload" accept="video/*" class="block w-full text-sm text-gray-400 file:mr-4 file:py-3 file:px-6 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700 file:cursor-pointer cursor-pointer"></div>
                </div>
                <div id="editor-section" class="hidden glass-effect p-8 rounded-2xl">
                    <div id="canvas-container" class="mb-8"><canvas id="main-canvas"></canvas></div>
                    <div id="controls-section">
                        <div id="mode-selection">
                            <h2 class="text-3xl font-bold mb-6 text-center gradient-text">2. Choose Your Mode</h2>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                                <button id="mode-audio" type="button" class="group p-6 rounded-xl bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 transition-all duration-300 transform hover:scale-105"><svg class="w-8 h-8 mx-auto mb-3 group-hover:scale-110 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path></svg><h3 class="text-xl font-bold mb-2">Audio Dubbing</h3><p class="text-sm opacity-90">Replace or overlay audio tracks</p></button>
                                <button id="mode-greenscreen" type="button" class="group p-6 rounded-xl bg-gray-600 cursor-not-allowed transition-all duration-300" disabled><div id="greenscreen-button-content"><div class="loader mx-auto mb-3"></div><h3 class="text-xl font-bold mb-2">Green Screen</h3><p class="text-sm opacity-90">Loading AI Model...</p></div></button>
                            </div>
                        </div>
                        <div id="recording-controls" class="hidden">
                            <h2 class="text-3xl font-bold mb-6 text-center gradient-text">3. Prepare Your Content</h2>
                            <div class="flex items-center justify-center mb-6"><label class="flex items-center space-x-3 cursor-pointer"><input type="checkbox" id="mute-original" class="w-5 h-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"><span class="text-gray-300 font-medium">Mute original video audio</span></label></div>
                            <div class="flex justify-center"><button id="launch-preview-btn" type="button" class="btn-secondary text-white font-bold py-4 px-8 rounded-xl text-lg transition-all duration-300 flex items-center justify-center">Launch Full Screen Preview</button></div>
                        </div>
                    </div>
                </div>
                <div id="playback-section" class="hidden glass-effect p-8 rounded-2xl">
                    <h2 class="text-3xl font-bold mb-6 text-center gradient-text">4. Your Masterpiece</h2>
                    <video id="final-video" controls playsinline class="w-full rounded-xl bg-black shadow-2xl mb-6"></video>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <a id="download-btn" href="#" download="video-dub-creation.webm" class="btn-primary text-center font-bold py-4 px-6 rounded-xl transition-all duration-300 flex items-center justify-center"><svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-4-4m4 4l4-4m-7-4.5V3a2 2 0 012-2h2a2 2 0 012 2v2.59"></path></svg>Download Video</a>
                        <button id="reset-btn" type="button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-4 px-6 rounded-xl transition-all duration-300 flex items-center justify-center"><svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>Start Over</button>
                    </div>
                </div>
            </div>
        </main>
        <div id="status-modal" class="custom-modal hidden"><div class="modal-content"><div id="modal-loader" class="loader mx-auto mb-4"></div><p id="status-message" class="text-lg text-gray-300 mb-4"></p><button id="modal-close-btn" type="button" class="hidden btn-primary font-bold py-3 px-6 rounded-lg mt-6">OK</button></div></div>
        
        <!-- Invisible video elements for processing -->
        <video id="video-player" playsinline muted style="position: absolute; left: -9999px;"></video>
        <video id="webcam-video" playsinline muted style="position: absolute; left: -9999px;"></video>
    </div>

    <!-- Full Screen Preview Overlay -->
    <div id="fullscreen-preview" class="hidden">
        <canvas id="fullscreen-canvas"></canvas>
        <div id="fullscreen-controls">
            <button id="record-btn">
                <div class="record-icon">
                    <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 16 16"><path d="M8 13A5 5 0 1 0 8 3a5 5 0 0 0 0 10z"/></svg>
                </div>
                <div class="stop-icon">
                     <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/></svg>
                </div>
            </button>
        </div>
        <div id="countdown-timer" class="hidden"></div>
        <button id="exit-preview-btn"><svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button>
        <button id="toggle-audio-btn">
            <div class="icon-unmuted">
                <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"></path></svg>
            </div>
            <div class="icon-muted">
                <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15zM17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2"></path></svg>
            </div>
        </button>
    </div>

    <script>
        const ui = {
            startBtn: document.getElementById('start-btn'), appContent: document.getElementById('app-content'), uploadSection: document.getElementById('upload-section'), editorSection: document.getElementById('editor-section'), playbackSection: document.getElementById('playback-section'), videoUpload: document.getElementById('video-upload'), videoPlayer: document.getElementById('video-player'), mainCanvas: document.getElementById('main-canvas'), canvasCtx: document.getElementById('main-canvas').getContext('2d'), webcamVideo: document.getElementById('webcam-video'), recordingControls: document.getElementById('recording-controls'), launchPreviewBtn: document.getElementById('launch-preview-btn'), resetBtn: document.getElementById('reset-btn'), statusModal: document.getElementById('status-modal'), statusMessage: document.getElementById('status-message'), modalLoader: document.getElementById('modal-loader'), modalCloseBtn: document.getElementById('modal-close-btn'), rawCameraPreview: document.getElementById('raw-camera-preview'), greenscreenPreviewCanvas: document.getElementById('greenscreen-preview-canvas'), greenscreenPreviewCtx: document.getElementById('greenscreen-preview-canvas').getContext('2d'), modeAudioBtn: document.getElementById('mode-audio'), modeGreenscreenBtn: document.getElementById('mode-greenscreen'), greenscreenButtonContent: document.getElementById('greenscreen-button-content'), muteOriginalCheckbox: document.getElementById('mute-original'), finalVideo: document.getElementById('final-video'), downloadBtn: document.getElementById('download-btn'), fullscreenPreview: document.getElementById('fullscreen-preview'), fullscreenCanvas: document.getElementById('fullscreen-canvas'), fullscreenCtx: document.getElementById('fullscreen-canvas').getContext('2d'), recordBtn: document.getElementById('record-btn'), countdownTimer: document.getElementById('countdown-timer'), exitPreviewBtn: document.getElementById('exit-preview-btn'), toggleAudioBtn: document.getElementById('toggle-audio-btn'), startSection: document.getElementById('start-section'), modeSelection: document.getElementById('mode-selection'), rawCameraPreviewContainer: document.getElementById('raw-camera-preview-container'), greenscreenPreviewContainer: document.getElementById('greenscreen-preview-container'),
        };

        let state = {
            mediaPipeModel: null, modelLoaded: false, activeMode: null, userMediaStream: null, recorder: null, animationFrameId: null, isRecording: false, isPreviewing: false, countdownTimerId: null, latestSegmentationMask: null,
            audioContext: null, videoAudioBuffer: null, micSourceNode: null, livePlaybackGainNode: null, recordingStreamDestination: null, activeVideoAudioSource: null, recordingStartTime: 0,
            maskCanvas: document.createElement('canvas'), maskCtx: null,
        };
        state.maskCtx = state.maskCanvas.getContext('2d');

        const showStatus = (message, isError = false, showButton = false) => {
            ui.statusMessage.textContent = message;
            ui.modalLoader.style.display = isError || showButton ? 'none' : 'block';
            ui.modalCloseBtn.style.display = isError || showButton ? 'block' : 'none';
            ui.statusModal.classList.remove('hidden');
        };

        const hideStatus = () => ui.statusModal.classList.add('hidden');

        const initializeApp = async () => {
            ui.startBtn.disabled = true;
            ui.startBtn.innerHTML = '<div class="loader"></div> Initializing...';
            showStatus('Requesting camera & microphone permissions...');
            try {
                state.userMediaStream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 }, audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } });
                ui.rawCameraPreview.srcObject = state.userMediaStream;
                ui.webcamVideo.srcObject = state.userMediaStream;
                await Promise.all([ui.rawCameraPreview.play(), ui.webcamVideo.play()]);
                
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                ui.startSection.classList.add('hidden');
                ui.appContent.classList.remove('hidden');
                hideStatus();
            } catch (err) {
                console.error('Media access error:', err);
                showStatus('Camera and microphone access is required. Please allow permissions and refresh the page.', true, true);
                ui.startBtn.innerHTML = 'Start Studio';
                ui.startBtn.disabled = false;
            }
        };
                ui.rawCameraPreview.srcObject = state.userMediaStream;
                ui.webcamVideo.srcObject = state.userMediaStream;
                await Promise.all([ui.rawCameraPreview.play(), ui.webcamVideo.play()]);
                // Always show raw camera preview after permissions
                ui.rawCameraPreviewContainer.classList.remove('hidden');
                ui.greenscreenPreviewContainer.classList.add('hidden');
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                ui.startSection.classList.add('hidden');
                ui.appContent.classList.remove('hidden');
                hideStatus();
                const arrayBuffer = await file.arrayBuffer();
                state.videoAudioBuffer = await state.audioContext.decodeAudioData(arrayBuffer);
            } catch (e) {
                console.error("Error decoding audio data:", e);
                showStatus("Could not process the audio from this video file. It might be corrupted or in an unsupported format.", true, true);
                return;
            }

            ui.videoPlayer.onloadedmetadata = () => {
                const w = ui.videoPlayer.videoWidth;
                const h = ui.videoPlayer.videoHeight;
                ui.mainCanvas.width = w;
                ui.mainCanvas.height = h;
                ui.fullscreenCanvas.width = w;
                ui.fullscreenCanvas.height = h;
                state.maskCanvas.width = w;
                state.maskCanvas.height = h;
                
                ui.videoPlayer.onseeked = () => renderFrame();
                ui.videoPlayer.currentTime = 0.01;

                ui.uploadSection.classList.add('hidden');
                ui.editorSection.classList.remove('hidden');
                hideStatus();
            };
        };
        
        const onMediaPipeResults = (results) => {
            state.latestSegmentationMask = results.segmentationMask;
        };

        const loadMediaPipeModelInBackground = async () => {
            try {
                if (!window.SelfieSegmentation) throw new Error('MediaPipe SelfieSegmentation library not loaded.');
                const selfieSegmentation = new SelfieSegmentation({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}` });
                selfieSegmentation.setOptions({ modelSelection: 1 });
                selfieSegmentation.onResults(onMediaPipeResults);
                state.mediaPipeModel = selfieSegmentation;
                state.modelLoaded = true;
                ui.modeGreenscreenBtn.disabled = false;
                ui.modeGreenscreenBtn.classList.remove('bg-gray-600', 'cursor-not-allowed');
                ui.modeGreenscreenBtn.classList.add('bg-gradient-to-r', 'from-teal-600', 'to-green-600', 'hover:from-teal-700', 'hover:to-green-700');
                ui.greenscreenButtonContent.innerHTML = `<svg class="w-8 h-8 mx-auto mb-3 group-hover:scale-110 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg><h3 class="text-xl font-bold mb-2">Green Screen</h3><p class="text-sm opacity-90">AI-powered background removal</p>`;
                sendWebcamFrameToMediaPipe();
            } catch (error) {
                console.error('--- DETAILED AI MODEL LOADING ERROR ---', error);
                ui.modeGreenscreenBtn.disabled = true;
                ui.modeGreenscreenBtn.classList.remove('bg-gray-600');
                ui.modeGreenscreenBtn.classList.add('bg-red-900', 'cursor-not-allowed');
                ui.greenscreenButtonContent.innerHTML = `<svg class="w-8 h-8 mx-auto mb-3 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg><h3 class="text-xl font-bold mb-2 text-red-400">AI Unavailable</h3><p class="text-sm opacity-90">Model failed to load. See console.</p>`;
            }
        };
        
        const sendWebcamFrameToMediaPipe = async () => {
            if (state.modelLoaded && state.mediaPipeModel && ui.webcamVideo.readyState >= 4) {
                await state.mediaPipeModel.send({image: ui.webcamVideo});
            }
            requestAnimationFrame(sendWebcamFrameToMediaPipe);
        };

        const setupMode = async (newMode) => {
            state.activeMode = newMode;
            if (state.activeMode === 'greenscreen') {
                if (!state.modelLoaded) { showStatus('The AI model is not available.', true, true); return; }
                ui.rawCameraPreviewContainer.classList.add('hidden');
                ui.greenscreenPreviewContainer.classList.remove('hidden');
            } else {
                ui.rawCameraPreviewContainer.classList.remove('hidden');
                ui.greenscreenPreviewContainer.classList.add('hidden');
            }
            ui.modeSelection.classList.add('hidden');
            ui.recordingControls.classList.remove('hidden');
            renderFrame();
        };

        const startRecordingAndPlayback = async () => {
            if (state.isRecording) return;
            state.isRecording = true;
            
            ui.recordBtn.classList.add('recording');
            ui.recordBtn.onclick = stopRecording;
            ui.exitPreviewBtn.classList.add('hidden');
            
            state.recordingStreamDestination = state.audioContext.createMediaStreamDestination();
            
            if (state.userMediaStream.getAudioTracks().length > 0) {
                state.micSourceNode = state.audioContext.createMediaStreamSource(state.userMediaStream);
                state.micSourceNode.connect(state.recordingStreamDestination);
            }

            state.activeVideoAudioSource = state.audioContext.createBufferSource();
            state.activeVideoAudioSource.buffer = state.videoAudioBuffer;
            
            state.livePlaybackGainNode = state.audioContext.createGain();
            const isMuted = ui.muteOriginalCheckbox.checked;
            state.livePlaybackGainNode.gain.value = isMuted ? 0 : 1;
            ui.toggleAudioBtn.classList.toggle('muted', isMuted);

            state.activeVideoAudioSource.connect(state.recordingStreamDestination);
            state.activeVideoAudioSource.connect(state.livePlaybackGainNode).connect(state.audioContext.destination);
            
            const canvasStream = ui.fullscreenCanvas.captureStream(30);
            const recordingAudioStream = state.recordingStreamDestination.stream;
            
            const finalStream = new MediaStream([
                ...canvasStream.getVideoTracks(), 
                ...recordingAudioStream.getAudioTracks()
            ]);

            state.recorder = new RecordRTC(finalStream, { type: 'video', mimeType: 'video/webm;codecs=vp9,opus', videoBitsPerSecond: 3500000 });
            
            ui.videoPlayer.currentTime = 0;
            await ui.videoPlayer.play();
            state.activeVideoAudioSource.start(0);
            state.recorder.startRecording();
            startContinuousCountdown();
            startRenderLoop();
        };

        const stopRecording = () => {
            if (!state.recorder || !state.isRecording) return;
            state.isRecording = false;
            
            if (state.animationFrameId) cancelAnimationFrame(state.animationFrameId);
            if (state.countdownTimerId) cancelAnimationFrame(state.countdownTimerId);

            showStatus('Processing video...');
            
            ui.videoPlayer.pause();
            if (state.activeVideoAudioSource) {
                try { state.activeVideoAudioSource.stop(); } catch(e) {/* Already stopped */}
            }
            
            state.recorder.stopRecording(() => {
                try {
                    const blob = state.recorder.getBlob();
                    ui.finalVideo.src = URL.createObjectURL(blob);
                    ui.downloadBtn.href = ui.finalVideo.src;
                    if (state.recorder) state.recorder.destroy();
                    if(state.micSourceNode) state.micSourceNode.disconnect();
                    state.recorder = null;
                    ui.editorSection.classList.add('hidden');
                    ui.playbackSection.classList.remove('hidden');
                    exitFullScreenPreview();
                    hideStatus();
                } catch (e) {
                    console.error("Error stopping recording:", e);
                    showStatus('Failed to process video.', true, true);
                }
            });
        };

        const formatTime = (timeInSeconds) => {
            const time = Math.max(0, timeInSeconds);
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        };

        const startContinuousCountdown = () => {
            state.recordingStartTime = performance.now();
            ui.countdownTimer.classList.remove('hidden');

            function updateTimer() {
                if (!state.isRecording) return; 
                
                const elapsedTime = (performance.now() - state.recordingStartTime) / 1000;
                const timeRemaining = ui.videoPlayer.duration - elapsedTime;
                ui.countdownTimer.textContent = formatTime(timeRemaining);

                if (timeRemaining > 0) {
                    state.countdownTimerId = requestAnimationFrame(updateTimer);
                } else {
                    ui.countdownTimer.textContent = "00:00";
                    // --- FINAL FIX: Automatically stop when timer hits zero. ---
                    stopRecording(); 
                }
            }
            state.countdownTimerId = requestAnimationFrame(updateTimer);
        };

        const launchFullScreenPreview = () => {
            state.isPreviewing = true;
            ui.fullscreenPreview.classList.remove('hidden');
            ui.videoPlayer.currentTime = 0.01;
            startRenderLoop();
        };

        const exitFullScreenPreview = () => {
            state.isPreviewing = false;
            state.isRecording = false;
            if (state.animationFrameId) cancelAnimationFrame(state.animationFrameId);
            if (state.countdownTimerId) cancelAnimationFrame(state.countdownTimerId);
            
            ui.videoPlayer.pause();
            if (state.activeVideoAudioSource) {
                 try { state.activeVideoAudioSource.stop(); } catch(e) {/* Already stopped */}
            }

            ui.fullscreenPreview.classList.add('hidden');
            ui.recordBtn.classList.remove('recording');
            ui.recordBtn.onclick = startRecordingAndPlayback;

            ui.exitPreviewBtn.classList.remove('hidden');
            ui.countdownTimer.classList.add('hidden');
            renderFrame();
        };

        const renderFrame = () => {
            const isLive = state.isPreviewing || state.isRecording;
            const canvas = isLive ? ui.fullscreenCanvas : ui.mainCanvas;
            const ctx = canvas.getContext('2d');

            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(ui.videoPlayer, 0, 0, canvas.width, canvas.height);

            if (state.activeMode === 'greenscreen' && state.modelLoaded && state.latestSegmentationMask) {
                state.maskCtx.clearRect(0, 0, state.maskCanvas.width, state.maskCanvas.height);
                
                state.maskCtx.filter = 'blur(5px)';
                state.maskCtx.drawImage(state.latestSegmentationMask, 0, 0, state.maskCanvas.width, state.maskCanvas.height);
                state.maskCtx.filter = 'none';

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                const webcam = ui.webcamVideo;
                const canvasRatio = canvas.width / canvas.height;
                const webcamRatio = webcam.videoWidth / webcam.videoHeight;
                let destWidth, destHeight, destX, destY;

                if (canvasRatio > webcamRatio) {
                    destWidth = canvas.width;
                    destHeight = destWidth / webcamRatio;
                    destX = 0;
                    destY = (canvas.height - destHeight) / 2;
                } else {
                    destHeight = canvas.height;
                    destWidth = destHeight * webcamRatio;
                    destY = 0;
                    destX = (canvas.width - destWidth) / 2;
                }
                tempCtx.drawImage(webcam, destX, destY, destWidth, destHeight);

                tempCtx.globalCompositeOperation = 'destination-in';
                tempCtx.drawImage(state.maskCanvas, 0, 0, canvas.width, canvas.height);
                
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(tempCanvas, -canvas.width, 0, canvas.width, canvas.height);
                ctx.restore();
            }
            ctx.restore();

            if (state.activeMode === 'greenscreen' && !isLive) {
                ui.greenscreenPreviewCtx.clearRect(0, 0, ui.greenscreenPreviewCanvas.width, ui.greenscreenPreviewCanvas.height);
                ui.greenscreenPreviewCtx.drawImage(canvas, 0, 0, ui.greenscreenPreviewCanvas.width, ui.greenscreenPreviewCanvas.height);
            }

            if (isLive) {
                state.animationFrameId = requestAnimationFrame(renderFrame);
            }
        };
        
        const startRenderLoop = () => {
            if (state.animationFrameId) cancelAnimationFrame(state.animationFrameId);
            state.animationFrameId = requestAnimationFrame(renderFrame);
        };

        const resetApp = () => window.location.reload();

        const waitForLibraries = () => {
            const interval = setInterval(() => {
                if (window.SelfieSegmentation && window.RecordRTC) {
                    clearInterval(interval);
                    loadMediaPipeModelInBackground();
                }
            }, 100);
        };

        // --- Event Listeners ---
        ui.startBtn.addEventListener('click', initializeApp);
        ui.videoUpload.addEventListener('change', handleVideoUpload);
        ui.modeAudioBtn.addEventListener('click', () => setupMode('audio'));
        ui.modeGreenscreenBtn.addEventListener('click', () => setupMode('greenscreen'));
        ui.launchPreviewBtn.addEventListener('click', launchFullScreenPreview);
        ui.recordBtn.addEventListener('click', startRecordingAndPlayback);
        ui.exitPreviewBtn.addEventListener('click', exitFullScreenPreview);
        ui.resetBtn.addEventListener('click', resetApp);
        ui.modalCloseBtn.addEventListener('click', hideStatus);
        ui.videoPlayer.addEventListener('ended', () => {
            if (state.isRecording) stopRecording();
        });
        ui.toggleAudioBtn.addEventListener('click', () => {
            if (!state.livePlaybackGainNode) return;
            const isMuted = ui.toggleAudioBtn.classList.toggle('muted');
            state.livePlaybackGainNode.gain.setValueAtTime(isMuted ? 0 : 1, state.audioContext.currentTime);
        });
        
        waitForLibraries();
    </script>
</body>
</html>